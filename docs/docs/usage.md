Usage
=======================


Compile
-------------------------

The isQ compiler receives the isQ source file as input, and the instruction format is as follows:

    isqc compile [options] <Input>

options:

* `--emit <FORMAT>` : output content format, format value can be `mlir, mlirqir, llvm, mlir-optimized, binary, out` \[default: `out`\]
* `-o, --output <OUTFILE>` : output file
* `-O, --opt-level <OPT_LEVEL>` : llvm opt-level such as `-O1, -O2, -O3` etc.
* `--target <TARGET_IR>` : target ir, now support `qir, open-qasm3, qcis` \[default: `qir`\]
* `--qcis-config <MAPPING_CONFIG_FILE>` : qcis mapping config file

You can compile isQ source file to [qir](https://github.com/qir-alliance/qir-spec) or [qcis](https://quantumcomputer.ac.cn/UserBook.html) using follow commands:

```bash
# compile to qir, default output file is source.so
isqc compile source.isq
# compile to qcis, default output file is source.qcis
isqc compile --target qcis --qcis-config MAPPING_CONFIG_FILE source.isq
```

Qcis instructions can run on real superconducting hardware, so isQ compiler provides qubit-mapping function. You should feed `mapping_config_file` like above. The file content needs to include the following fields:

```json
{
// required
    "qbit_num": 12, // qubit number on hardware
    "topo": [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12]], // topology of hardware
// option 
    "init_map": "simulated_annealing" // the way to get init mapping
}

```

Of course, you can get the intermediate results of compilation by using `--emit` like that:

```bash
# compile to mlir, default output file is source.mlir
isqc compile --emit mlir source.isq
# compile to llvm(qir), default output file is source.ll
isqc compile --emit llvm source.isq
```

Simulate
------------------

#### qir

The simulator of isQ provides the simulation of `qir`. The input must be a .so file generated by compiler.  The instruction format is as follows

	isqc simulate [options] <Input>

options:

* `--shots <NUM>`: simulate times, default is 1
* `--debug`: use debug mod and get the `print` result
* `--cuda <NUM>`: use gpu, `NUM` is the number of qubits to be simulated
* `-i <INT>`: int type paramter
* `-d <DOUBLE>` double type paramter
```bash
# simulate in cpu
isqc simulate ./source.so
# simulate in gpu
isqc simulate --cuda 10 ./source.so
# run 10 time and use debug mod
isqc simulate --shots 10 --debug ./source.so
```

The output is the statistical result of measurement in source.isq, like `{"00": 4, "11": 6}`.  And if use debug mod, `print` result of each simulation can also output to stderr, like `{ith simulate print: 1 1}`. When the shot_num is large, there will be many print result. It is suitable that redirect the stderr to a file. For example

```bash
# redirect print result to a file
isqc simulate --shots 100 --debug ./source.so 2>res.txt
```
output
```bash
{"00": 4, "11": 6}
```
res.txt
```bash
0th simulation print:
1
2
1th simulation print:
...
```


#### qcis

isQ simulator can also simulate `qcis`and the option is `--qcis`. Another option is `--shots <NUM>` which specifies the number of simulation runs, defualt is 1. The output is the statistical result of the measurement, like `{"00": 4, "11": 6}`. For example:

```bash
# simulate qcis, 1000 times
isqc simulate --qcis --shots 1000 ./source.qcis
```


Run
-------------------------

You can use isQâ€™s `run` command to compile and simulate quantum programs (compile to `qir`) 
```bash
	isqc run [options] <Input>
```

options

* `--shots <NUM>`: simulate times, default is 1
* `--debug`: use debug mod and get the `print` result

<script type="text/javascript" id="MathJax-script" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/tex-mml-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>